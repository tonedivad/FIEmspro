% wll-17-09-2007
%
\name{accest}
\alias{accest}
\alias{accest.formula}
\alias{accest.default}
\alias{accest.dlist}
\alias{print.accest}
\alias{summary.accest}
\alias{print.summary.accest}

\title{Classification Wrapper Using Customised Classifiers}

% ----------------------------------------------------------------------------
\description{
Wrapper function for calculating classification 
estimates using pre-defined data partitioning sets (\code{\link{valipars}} and 
\code{\link{trainind}}). This function works 
with two type of classifiers. First  generic classifiers that fulfil R standards to define predictive techniques such as the ones available in packages like \pkg{MASS}, \pkg{e1071} or  \code{randomForest} and \code{nlda} are normally handle with \code{accest}: the name of function (\code{clmeth} in the \code{accest} call) must be accompanied with an S3 method \code{predict}; the later function should return a list with component 'class' (hard classification) and if possible 'prob' or  'posterior' for class probabilities. If the algorithm doesn't fulfil these requirements, two postions can be adopted: 1) define explicitly the algorithm so that it means R standards 2) define customised a function that returns necessary informations. The second ('quicky and dirty') approach is illustrated in an example given below.  Unless the classifier can only cope with two-class tasks, this function allows the manipulation of any problem complexity. Three types 
of estimates are given for each replication: accuracy, so-called margin and 
AUC (see details). Data input can be 
in the form of \code{data} matrix + \code{class} vector, following the classic formula type or
derived from \code{\link{dat.sel1}}.

}

% ----------------------------------------------------------------------------
\usage{
accest(\dots)

\method{accest}{default}(dat, cl, clmeth, pars = NULL, tr.idx = NULL, verb=TRUE, clmpi=NULL, seed=NULL, \dots)

\method{accest}{formula}(formula, data = NULL, \dots, subset, na.action = na.omit)

\method{accest}{dlist}(dlist,  clmeth,pars = NULL, tr.idx = NULL, \dots)

}

% ----------------------------------------------------------------------------
\arguments{
  \item{formula}{
    A formula of the form \code{groups ~ x1 + x2 + \dots}  That is, the
    response is the grouping factor and the right hand side specifies
    the (non-factor) discriminators.
  }
  \item{data}{
    Data frame from which variables specified in \code{formula} are
    preferentially to be taken.
  }
  \item{dlist}{
    A matrix or data frame containing the explanatory variables if no formula is
    given as the principal argument.
  }
  \item{dat}{
    A matrix or data frame containing the explanatory variables if no formula is
    given as the principal argument.
  }
  \item{cl}{
    A factor specifying the class for each observation if no formula principal 
    argument is given.
  }
  \item{clmeth}{
    Classifier function. 
    For details, see \code{note} below.
 
  }             
  \item{pars}{
    A list of parameters using by the resampling method such as 
    \emph{Leave-one-out cross-validation}, \emph{Cross-validation}, 
    \emph{Bootstrap} and \emph{Randomised validation (holdout)}.
  	See \code{\link{valipars}} for details.
  }
  \item{tr.idx}{
  User defined index of training samples. Can be generated by \code{trainind}.
  }
  \item{verb}{
  Should iterations be printed out?
  }
  \item{clmpi}{
  snow cluster information
  }
  \item{seed}{
  Seed.
  }
  \item{\dots}{Additional parameters to be passed to \code{clmeth}.}
  \item{subset}{
    Optional vector, specifying a subset of observations to be used.
  }
  \item{na.action}{
    Function which indicates what should happen when the data
    contains \code{NA}'s, defaults to \code{\link{na.omit}}.
  } 
}

% ----------------------------------------------------------------------------
\details{
Seexxxx for common details. 
}

% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\value{
  An object of class \code{accest}, including the components:
  \item{clmeth}{Classification method used.}
  \item{acc}{Average accuracy.}
  \item{acc.iter}{Accuracy at each iteration.}
  \item{acc.std}{Standard derivation of accuracy.}
  \item{mar}{Average predictive margin.}
  \item{mar.iter}{Predictive margin of each iteration.}
  \item{auc}{Average area under receiver operating curve (AUC).}
  \item{auc.iter}{AUC of each iteration.}
  \item{sampling}{Sampling scheme used.} 
  \item{niter}{Number of iterations.}
  \item{nreps}{Number of replications at each iteration. }
  \item{acc.boot}{Detailed bootstrap accuracy estimates when bootstrap validation method is employed.}
  \item{argfct}{Arguments passed to the classifier. }
  \item{pred.all}{For each iteration, list of the fold/bootstrap id and the true and predicted classes.}
  \item{cl.task}{Discrimination task.}
  \item{mod}{List of information return by the user defined classifier function. }
 
}

% ----------------------------------------------------------------------------
\author{
  David Enot \email{dle@aber.ac.uk} and Wanchang Lin \email{wll@aber.ac.uk}
}

\seealso{
  \code{\link{valipars}}, \code{\link{trainind}}
}

% ----------------------------------------------------------------------------
\examples{

## -----------------------------------------------------------------
## simple customised function
## sameasrf simply reproduces the RF modelling task
sameasrf <- function(data,...){
  dots <- list(...)

  ## Build RF model and predict dat.te 
  mod  <- randomForest(data$tr,data$cl,...)
  ## Soft predictions (optional if ROC/margin analyses required)
  prob <- predict(mod,data$te,type="vote")
  ## Hard predictions 
  pred <- predict(mod,data$te)

  # For illustration, mod does not contain anything 
  list(mod=NULL,pred=pred,prob=prob,arg=dots)
}

## -----------------------------------------------------------------
## compare accest with randomForest 
## and sameasrf
data(iris)
dat=as.matrix(iris[,1:4])
cl=as.factor(iris[,5])
pars   <- valipars(sampling = "boot",niter = 2, nreps=10)
tr.idx <- trainind(iris$Species,pars)

set.seed(71)
acc.1 <- accest(dat,cl, clmeth = "sameasrf", 
                   pars = pars,tr.idx = tr.idx,ntree = 200)
summary(acc.1)

set.seed(71)
acc.2 <- accest(dat,cl, clmeth = "randomForest", 
                   pars = pars,tr.idx = tr.idx,ntree = 200)
summary(acc.2)

### compare acc.1 and acc.2 bootstrap error estimates
print(acc.1$acc.boot-acc.2$acc.boot)

#########################################
## Try formula type
set.seed(71)
acc.3 <- accest(Species~., data = iris, clmeth = "randomForest", 
                   pars = pars,tr.idx = tr.idx,ntree = 200)
summary(acc.3)

## Try dlist type from dat.sel1
set.seed(71)
dat2=dat.sel1(dat,cl,pars=pars)
acc.4 <- accest(dat2[[1]], clmeth = "randomForest", 
                   pars = pars,tr.idx = tr.idx,ntree = 200)
summary(acc.4)


}

\keyword{classif}
